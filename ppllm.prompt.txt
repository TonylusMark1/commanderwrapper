=== Project File Structure ===

CommanderWrapper/
├─ examples/
│  └─ basic.ts
├─ src/
│  ├─ HelpGen.ts
│  ├─ index.ts
│  ├─ types.ts
│  ├─ Utils.ts
│  └─ Validation.ts
├─ .gitignore
├─ .npmignore
├─ package.json
├─ README.md
├─ tsconfig.json
└─ tsup.config.ts

=== File Contents ===

File: CommanderWrapper\.gitignore
════════════════════════════════════════
```
# Directories
node_modules/
dist/

# System-generated files
.DS_Store
Thumbs.db
```

File: CommanderWrapper\.npmignore
════════════════════════════════════════
```
# Exclude version control related files
.gitignore

# System-generated files
.DS_Store
Thumbs.db

# Configs
tsup.config.ts

# Exclude files and folder to leave only essential files
.git
.vscode
src
CHANGELOG.md
TODO
tsconfig.json
```

File: CommanderWrapper\examples\basic.ts
════════════════════════════════════════
```
import CommanderWrapper from '../src/index.js';

// Create a new instance of the CLI
const cli = new CommanderWrapper();

// Register a command called "greet"
cli.registerCommand(
	'greet',
	'Greet a user with a custom message',
	{
		strictMode: true,
		arguments: [
			{ name: 'name', required: true, parser: String, validation: [/^[a-zA-Z0-9]+$/] }
		]
	},
	(registerOption) => {
		// Register options for the "greet" command
		registerOption({ groupName: 'Greeting' }, {
			flags: '-t, --times <number>',
			description: 'Number of times to repeat the greeting',
			defaultValue: 1,
			valueParser: (value) => parseInt(value, 10),
			validation: [1, 2, 3, 4, 5]
		});

		registerOption({ groupName: 'Greeting' }, {
			flags: '-u, --uppercase',
			description: 'Print the greeting in uppercase letters'
		});
	}
);

// Parse the CLI arguments
cli.parse();

// Retrieve the parsed arguments and options
const args = cli.getCommandArguments<{ name: string }>();
const options = cli.getOptions<{ times: number; uppercase: boolean }>();

console.log(args, options);

// Generate the greeting message
let message = `Hello, ${args.name}!`;
if (options.uppercase) {
	message = message.toUpperCase();
}

// Repeat the message based on the --times option
for (let i = 0; i < options.times; i++) {
	console.log(message);
}

```

File: CommanderWrapper\package.json
════════════════════════════════════════
```
{
  "name": "commanderwrapper",
  "version": "0.0.2",
  "description": "Simple commander wrapper",
  "type": "module",
  "main": "dist/index.js",
  "author": "tonylus",
  "license": "ISC",
  "repository": "https://github.com/TonylusMark1/commanderwrapper",
  "dependencies": {
    "colorette": "^2.0.20",
    "commander": "^13.1.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "tsup": "^8.4.0",
    "typescript": "^5.8.2"
  },
  "scripts": {
    "build": "tsup",
    "prepare": "npm run build"
  }
}

```

File: CommanderWrapper\README.md
════════════════════════════════════════
```

# CommanderWrapper

Simple wrapper for Commander.js — with grouped/tagged options, rich help and validation.

---

## 📦 Installation

```bash
npm install commanderwrapper
```

## 🚀 Features

- 📋 Typed options & arguments
- 🎨 Custom groups and tags
- ✅ Validation with values, RegExp, or custom pattern objects
- 🧩 Scoped option registration
- 🖍️ Rich help text generation with grouping and hints
- 🧩 `getOptions()` — per group/tags/only user-provided
- 🎯 `getCommandArguments()` — retrieve parsed arguments
- 🧪 `isOptionValueValid()` — check if value fits validation

## 🛠️ Usage

```ts
import CommanderWrapper from 'commanderwrapper';

const cli = new CommanderWrapper();

cli.registerCommand('serve', 'Start the server', {
  strictMode: true,
  arguments: [
    { name: 'port', required: true, parser: Number, validation: [3000, 8080] }
  ]
}, (registerOption) => {
  registerOption({ groupName: 'General' }, {
    flags: '-h, --host <host>',
    description: 'Hostname',
    defaultValue: 'localhost',
  });

  registerOption({ groupName: 'General', tags: ['network'] }, {
    flags: '--secure',
    description: 'Enable HTTPS',
  });
});

cli.parse();

const args = cli.getCommandArguments();
const options = cli.getOptions();

console.log({ args, options });
```

## 🎨 Help Text Example

Automatically generates global and command-specific help:

```
Available Commands:

  serve
    Start the server

Tip: For detailed options, use <command> --help
```

For command-specific help:
```
Arguments:

  port (required)

Options for command: serve

General:

  -h, --host <host>     Hostname (Default: "localhost")
  --secure              Enable HTTPS
```

## 🔍 API Reference

### `registerCommand(commandName, description, options?, setup?)`

Define a command with description and options.

| Param | Type | Description |
|-------|------|-------------|
| `commandName` | `string` | Name of the command |
| `description` | `string` | Description of the command |
| `options` | `RegisterCommandOptions` | Additional command options |
| `setup` | `(registerOption) => void` | Callback to register options scoped to this command |

### `registerOption(meta, config)`

Register an option for the active command.

| Param | Type | Description |
|-------|------|-------------|
| `meta` | `RegisterOptionMeta` | Grouping & tags |
| `config` | `OptionConfig<T>` | Option configuration |

### `parse(argv?)`

Parse process arguments.

### `getOptions()`

Retrieve parsed options.

### `getCommandArguments()`

Retrieve parsed arguments.

### `isOptionValueValid(optionName, value)`

Validate an option value.

## 🔧 Types

You have full types support:
- `OptionConfig<T>`
- `RegisterOptionMeta`
- `ValidationRule<T>`
- `CommandArgument`

## 📄 License

ISC © [tonylus](https://github.com/TonylusMark1)

```

File: CommanderWrapper\src\HelpGen.ts
════════════════════════════════════════
```
import * as colorette from 'colorette';

import * as Utils from "./Utils.js";

import CommanderWrapper from 'commanderwrapper/src/index.js';

//

type Friendly_CommanderWrapper = Omit<CommanderWrapper, "commands" | "getCommand"> & {
    commands: CommanderWrapper["commands"];
    getCommand: CommanderWrapper["getCommand"];
}

//

export default class HelpGen {
    private readonly parent: Friendly_CommanderWrapper;

    //

    constructor(parent: Friendly_CommanderWrapper) {
        this.parent = parent;
    }

    //

    generateGlobalHelpText(): string {
        const lines: string[] = [];

        //

        lines.push(
            colorette.bold(`Available Commands`) +
            colorette.italic(` (for detailed options, use ${colorette.cyan('<command> --help')}):`) +
            `\n`
        );

        //

        for (const [commandName, commandMeta] of this.parent.commands.entries()) {
            const description = commandMeta.commander.description() || '';

            lines.push(`  ${colorette.cyan(commandName)}`);

            if (description.trim() !== '') {
                lines.push(`    ${colorette.italic(description)}`);
            }

            lines.push('');
        }

        lines.push('');

        //

        return lines.join('\n');
    }

    generateHelpTextForCommand(commandName: string): string {
        const lines: string[] = [];

        //

        lines.push(this.generateCommandFullIntroduction(commandName));
        lines.push(this.generateCommandOptionsFullIntroduction(commandName));

        //

        return lines.join('\n');
    }

    //

    generateCommandFullIntroduction(commandName: string) {
        const commandMeta = this.parent.getCommand(commandName);

        //

        const lines: string[] = [];

        //

        lines.push(colorette.bold(`Command:`) + ` ${commandName}` + " " + Utils.FormatCommandArgumentsInLine(commandMeta));
        lines.push("");
        lines.push(colorette.italic(`  ${commandMeta.commander.description()}`));
        
        //

        if (commandMeta.arguments.length) {
            lines.push("");

            const args: { left: string, right?: string }[] = commandMeta.arguments.map(arg => {
                return {
                    left: Utils.FormatCommandArgument(arg),
                    right: arg.config.validation ? `Allowed: ${Utils.FormatValidationRules(arg.config.validation)}` : undefined
                }
            });

            const longestLeftLength = args.reduce((max, arg) => Math.max(max, arg.left.length), 0);
            args.forEach(arg => {
                arg.left = arg.left.padEnd(longestLeftLength + 3);

                lines.push(`  ` + colorette.cyan(arg.left) + (arg.right ? arg.right : ""));
            });
        }

        //

        return lines.join("\n");
    }

    generateCommandOptionsFullIntroduction(commandName: string) {
        const commandMeta = this.parent.getCommand(commandName);

        //

        const lines: string[] = [];

        //

        lines.push(colorette.bold(`\nOptions:\n`));

        //

        const groups = Object.entries(commandMeta.groups);

        groups.unshift(["built-in", [{
            groupName: "built-in",
            flags: "-h, --help",
            description: "Show help",
            tags: [],
            commanderOption: null as any
        }]]);

        //

        const allOptions = groups.flatMap(([, options]) => options);
        const flagPadding = Math.max(...allOptions.map(opt => opt.flags.length)) + 2;

        for (const [groupName, options] of groups) {
            lines.push("  " + colorette.underline(`${groupName}:`) + "\n");

            for (const option of options) {
                const flags = colorette.cyan(option.flags.padEnd(flagPadding));
                lines.push(`    ${flags} ${option.description}`);
            }

            lines.push('');
        }

        lines.push('');

        return lines.join('\n');
    }
}

```

File: CommanderWrapper\src\index.ts
════════════════════════════════════════
```
import { Command, Option } from 'commander';
import * as colorette from 'colorette';

import * as Types from "./types.js";

import * as Utils from "./Utils.js";
import HelpGen from "./HelpGen.js";
import Validation from "./Validation.js";

//

export type {ValidationRule, OptionConfig, CommandArgument, RegisterOptionMeta, ScopedRegisterOptionCallback} from "./types.js";

/*type ValidationRule<T> = Types.ValidationRule<T>
type OptionConfig<T> = Types.OptionConfig<T>
type CommandArgument = Types.CommandArgument
type RegisterOptionMeta = Types.RegisterOptionMeta
type ScopedRegisterOptionCallback = Types.ScopedRegisterOptionCallback

export {
    ValidationRule,
    OptionConfig,
    CommandArgument,
    RegisterOptionMeta,
    ScopedRegisterOptionCallback
};*/

//

export default class CommanderWrapper {
    static readonly UNGROUPED_GROUP_NAME = 'ungrouped';

    //

    private helpGen = new HelpGen(this as any);
    private validation = new Validation(this as any);

    private cmderPrg = new Command();

    private commands: Map<string, Types.CommandMeta> = new Map();

    private usedCommand: string = null as any;

    //

    constructor() {
    }

    //

    registerCommand(
        commandName: string,
        description: string,
        opts?: Types.RegisterCommandOptions,
        setup?: (registerOption: Types.ScopedRegisterOptionCallback) => void
    ) {
        const command = this.obtainCommand(commandName, opts?.isDefault ?? false, opts?.arguments);

        command.commander
            .description(description)
            .action((...args: any[]) => {
                this.usedCommand = commandName;

                this.processCommandArguments(command, args);
            });

        command.commander.allowUnknownOption(!(opts?.strictMode ?? true));

        if (setup) {
            const scopedRegisterOption: Types.ScopedRegisterOptionCallback = <T>(meta: Types.RegisterOptionMeta, config: Types.OptionConfig<T>) => {
                this.registerOption(commandName, meta, config);
            };

            setup(scopedRegisterOption);
        }
    }

    private processCommandArguments(command: Types.CommandMeta, args: any[]): void {
        const parsedArgs: { config: Types.CommandArgument; value: any }[] = [];

        for (let i = 0; i < command.arguments.length; i++) {
            const argConfig = command.arguments[i].config;
            const rawValue = args[i];

            if (argConfig.required && rawValue === undefined)
                throw new Error(colorette.red(`Missing required argument: ${colorette.yellow(argConfig.name)}`));

            if (rawValue !== undefined) {
                const parsedValue = argConfig.parser ? argConfig.parser(rawValue) : rawValue;

                if (argConfig.validation && !this.validation.isValueValid(parsedValue, argConfig.validation)) {
                    const allowed = Utils.FormatValidationRules(argConfig.validation);
                    throw new Error(colorette.red(`Invalid value for argument "${colorette.yellow(argConfig.name)}".\n${colorette.green('Allowed')}: ${allowed}`));
                }

                parsedArgs.push({ config: argConfig, value: parsedValue });
            }
            else {
                parsedArgs.push({ config: argConfig, value: undefined });
            }
        }

        command.arguments = parsedArgs;
    }

    //

    registerOption<T>(commandName: string, meta: Types.RegisterOptionMeta, config: Types.OptionConfig<T>) {
        const command = this.getCommand(commandName);

        //

        const groupName = meta.groupName ?? CommanderWrapper.UNGROUPED_GROUP_NAME;
        const tags = meta.tags ?? [];

        //

        const commanderOption = new Option(config.flags, config.description);

        if (config.defaultValue !== undefined) {
            commanderOption.default(config.defaultValue);
        }

        //

        if (config.validation) {
            if (commanderOption.isBoolean())
                throw new Error(`Option "${config.flags}" is a boolean flag, but validation was provided.`);

            //

            const invalidRule = this.validation.findFirstInvalidRule(config.validation);

            if (invalidRule)
                throw new Error(`Invalid validation rule for option "${config.flags}" ${JSON.stringify(invalidRule)}.`);
        }

        //

        const option: Types.RegisteredOption<T> = {
            ...config,

            commanderOption,

            groupName,
            tags
        };

        //

        const parserCallback = this.createOptionArgParser(option, config, command);
        commanderOption.argParser(parserCallback);

        //

        if (commanderOption.isBoolean()) {
            this.getLongFlagNames(commanderOption).forEach(longFlag => {
                command.commander.option(`--no-${longFlag}`, "", () => {
                    command.userProvidedOptions.add(option.commanderOption.attributeName());
                    return false;
                }, false);
            });
        }

        //

        if (option.defaultValue !== undefined)
            this.validateOptionValue(option.defaultValue, option, true);

        //

        this.enhanceDescription(option);

        //

        if (!command.groups[groupName])
            command.groups[groupName] = [];

        command.groups[groupName].push(option);

        //

        command.commander.addOption(commanderOption);
    }

    private createOptionArgParser<T>(option: Types.RegisteredOption<T>, config: Types.OptionConfig<T>, command: Types.CommandMeta): (value: any) => any {
        if (option.commanderOption.isBoolean()) {
            return (value: any) => {
                command.userProvidedOptions.add(option.commanderOption.attributeName());
                return true;
            };
        } else {
            return (value: any) => {
                command.userProvidedOptions.add(option.commanderOption.attributeName());

                const parsedValue = config.valueParser ? config.valueParser(value) : value;

                this.validateOptionValue(parsedValue, option, false);

                if (option.onValidate)
                    option.onValidate(parsedValue);

                return parsedValue;
            };
        }
    }

    //

    parse(argv?: string[]) {
        this.cmderPrg.helpInformation = () => this.helpGen.generateGlobalHelpText();
        this.cmderPrg.parse(argv || process.argv);
    }

    //

    getUsedCommand() {
        return this.usedCommand;
    }

    getOptions<OBJ extends Record<string, any> = Record<string, any>>(options?: { onlyUserProvided?: boolean; groupName?: string; tags?: string[] }) {
        const commandName = this.usedCommand;

        if (!commandName)
            throw new Error('No command has been used. Cannot retrieve options.');

        //

        const command = this.getCommand(commandName);
        const opts = command.commander.opts();
        const result: any = {};

        //

        const groups = options?.groupName
            ? { [options.groupName]: command.groups[options.groupName] ?? [] }
            : command.groups;

        //

        for (const groupOptions of Object.values(groups)) {
            for (const option of groupOptions) {
                const hasAllTags = options?.tags ? options.tags.every(tag => option.tags.includes(tag)) : true;

                if (!hasAllTags)
                    continue;

                const optionName = option.commanderOption.attributeName();

                if (!options?.onlyUserProvided || command.userProvidedOptions.has(optionName))
                    result[optionName] = opts[optionName];
            }
        }

        //

        return result as OBJ;
    }

    getCommandArguments<OBJ extends Record<string, any> = Record<string, any>>(): OBJ {
        const command = this.getCommand(this.usedCommand);

        //

        const result: any = {};

        for (const arg of command.arguments)
            result[arg.config.name] = arg.value;

        //

        return result as OBJ;
    }

    //

    hasUserSetOption(commandName: string, optionName: string) {
        const command = this.getCommand(commandName);
        return command.userProvidedOptions.has(optionName);
    }

    isOptionValueValid<T>(optionName: string, value: T): boolean | undefined;
    isOptionValueValid<T>(optionName: string, value: T, ignoreAbsence: false): boolean;
    isOptionValueValid<T>(optionName: string, value: T, ignoreAbsence: true): boolean | undefined;
    isOptionValueValid<T>(optionName: string, value: T, ignoreAbsence: boolean = true): boolean | undefined {
        const command = this.getCommand(this.usedCommand);

        for (const groupOptions of Object.values(command.groups)) {
            for (const option of groupOptions) {
                if (option.commanderOption.attributeName() === optionName)
                    return this.validation.isValueValid(value, option.validation);
            }
        }

        if ( !ignoreAbsence )
            throw new Error(`Option "${optionName}" not found in command "${this.usedCommand}".`);
    }

    //

    private getCommand(commandName: string) {
        const command = this.commands.get(commandName);

        if (!command)
            throw new Error(`Command "${commandName}" not found.`);

        return command;
    }

    private obtainCommand(commandName: string, isDefault: boolean = false, commandArgs: Types.CommandArgument[] = []) {
        let meta: Types.CommandMeta | undefined = this.commands.get(commandName)

        if (meta)
            return meta;

        //

        const argString = commandArgs
            .map(arg => arg.required ? `<${arg.name}>` : `[${arg.name}]`)
            .join(' ');

        //

        const cmd_nameAndArgs = argString ? `${commandName} ${argString}` : commandName;
        const cmd_opts = { isDefault };

        const commander = this.cmderPrg.command(cmd_nameAndArgs, cmd_opts);

        meta = {
            commander,
            groups: {},
            userProvidedOptions: new Set(),
            arguments: commandArgs.map(arg => ({ config: arg, value: undefined })),
        };

        //

        commander.helpInformation = () => this.helpGen.generateHelpTextForCommand(commandName);

        //

        this.commands.set(commandName, meta);

        //

        return meta;
    }

    //

    private getLongFlagNames(option: Option) {
        const matches = Array.from(option.flags.matchAll(/--([a-zA-Z0-9-]+)/g));
        return matches.map(match => match[1]);
    }

    private validateOptionValue<T>(value: T, option: Types.RegisteredOption<T>, isDefault: boolean) {
        const isValid = this.validation.isValueValid(value, option.validation);

        if (!isValid) {
            const source = isDefault ? 'Default value' : 'Invalid value';
            const allowed = Utils.FormatValidationRules(option.validation!);

            throw new Error(colorette.red(`${source} for option "${colorette.yellow(option.commanderOption.attributeName())}" is not allowed.\n${colorette.green('Allowed')}: ${allowed}`));
        }
    }

    //

    private enhanceDescription<T>(option: Types.RegisteredOption<T>) {
        const parts: string[] = [];

        //

        parts.push(option.description);

        //

        if (option.defaultValue !== undefined)
            parts.push(`(${colorette.green('Default')}: ${colorette.yellow(JSON.stringify(option.defaultValue))})`);

        if (option.commanderOption.isBoolean()) {
            const longFlagNames = this.getLongFlagNames(option.commanderOption);

            if (longFlagNames.length > 0) {
                const flags = longFlagNames.map(name => colorette.cyan(`--no-${name}`)).join(', ');
                parts.push(`(${colorette.green('Tip')}: Use ${flags} to explicitly set false)`);
            }
        }

        if (option.validation && option.validation.length > 0) {
            const allowed = Utils.FormatValidationRules(option.validation);
            parts.push(`(${colorette.green('Allowed')}: ${colorette.yellow(allowed)})`);
        }

        //

        option.description = parts.filter(Boolean).join(' ');
    }
}
```

File: CommanderWrapper\src\types.ts
════════════════════════════════════════
```
import { Command, Option } from 'commander';

//

export type ValidationRule<T> =
    | (T extends any[] ? never : T)
    | RegExp
    | { pattern: RegExp; description: string };

//

export interface OptionConfig<T> {
    flags: string;
    description: string;
    defaultValue?: T;
    validation?: ValidationRule<T>[];
    onValidate?: (value: T) => void;
    valueParser?: (value: string) => any;
}

export interface RegisterOptionMeta {
    groupName?: string;
    tags?: string[];
}

export interface RegisteredOption<T> extends OptionConfig<T>, Required<RegisterOptionMeta> {
    commanderOption: Option;
}

//

export interface RegisterCommandOptions {
    strictMode?: boolean;
    isDefault?: boolean;
    arguments?: CommandArgument[];
}

export interface CommandArgument {
    name: string;
    required?: boolean;
    parser?: (value: string) => any;
    validation?: ValidationRule<any>[];
}

export interface CommandGroup {
    [groupName: string]: RegisteredOption<any>[];
}

export interface CommandMeta {
    commander: Command;
    groups: CommandGroup;
    userProvidedOptions: Set<string>;
    arguments: CommandMetaArgument[];
}

export interface CommandMetaArgument {
    config: CommandArgument;
    value: any;
}

//

export type ScopedRegisterOptionCallback = <T>(meta: RegisterOptionMeta, config: OptionConfig<T>) => void;
```

File: CommanderWrapper\src\Utils.ts
════════════════════════════════════════
```
import * as Types from "./types.js";

//

export function FormatValidationRules<T>(validation: Types.ValidationRule<T>[]) {
    return validation
        .map(rule => {
            if (rule instanceof RegExp)
                return rule.toString();

            if (typeof rule === 'object' && rule !== null && 'pattern' in rule)
                return `<${rule.description}>`;

            return JSON.stringify(rule);
        })
        .filter(Boolean)
        .join(', ');
}

//

export function FormatCommandArgumentsInLine(commandMeta: Types.CommandMeta) {
    return commandMeta.arguments
        .map(arg => FormatCommandArgument(arg))
        .join(" ");
}

export function FormatCommandArgument(arg: Types.CommandMetaArgument) {
    return (arg.config.required ? `<${arg.config.name}>` : `[${arg.config.name}]`);
}
```

File: CommanderWrapper\src\Validation.ts
════════════════════════════════════════
```
import * as Types from "commanderwrapper/src/types.js";

import CommanderWrapper from 'commanderwrapper/src/index.js';

//

export default class Validation {
    private readonly parent: CommanderWrapper;

    //

    constructor(parent: CommanderWrapper) {
        this.parent = parent;
    }

    //

    findFirstInvalidRule<T>(validation: Types.ValidationRule<T>[]) {
        for (const rule of validation) {
            const isDirectValue = typeof rule === 'string' || typeof rule === 'number' || typeof rule === 'boolean';
            const isRegExp = rule instanceof RegExp;
            const isPatternObject =
                typeof rule === 'object' && rule !== null &&
                'pattern' in rule && rule.pattern instanceof RegExp &&
                'description' in rule && typeof rule.description === 'string';

            if (!isDirectValue && !isRegExp && !isPatternObject)
                return rule;
        }
    }

    isValueValid<T>(value: T, validation?: Types.ValidationRule<T>[]): boolean {
        if (!validation || validation.length === 0)
            return true;

        return validation.some(rule => {
            if (rule instanceof RegExp)
                return rule.test(String(value));

            if (typeof rule === 'object' && rule !== null && 'pattern' in rule)
                return rule.pattern.test(String(value));

            return rule === value;
        });
    }
}

```

File: CommanderWrapper\tsconfig.json
════════════════════════════════════════
```
{
    "compilerOptions": {
        "declaration": true,
        "declarationDir": "dist",
        "emitDeclarationOnly": false,
        "target": "ES2022",
        "module": "NodeNext",
        "moduleResolution": "nodenext",
        "outDir": "dist",
        "rootDir": "src",
        "esModuleInterop": true,
        "strict": true
    },
    "include": [
        "src/**/*"
    ]
}
```

File: CommanderWrapper\tsup.config.ts
════════════════════════════════════════
```
import * as TSUP from 'tsup';

//

export default TSUP.defineConfig({
    entry: ['src/index.ts'],
    outDir: "dist",
    format: ['esm'],
    sourcemap: true,
    clean: true,
    dts: true,
});
```
